/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/InteractiveWatch.ts":
/*!*********************************!*\
  !*** ./src/InteractiveWatch.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _loadImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadImage */ \"./src/loadImage.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar InteractiveWatch = /** @class */ (function () {\n    function InteractiveWatch() {\n        // these images must all have exactly the same dimensions\n        this.images = { body: new Image(), hour: new Image(), minute: new Image(), second: new Image() };\n        this.rotations = { body: 0, hour: 0, minute: 0, second: 0 };\n        // these are base values that will be captured and changed accordingly\n        this.baseHour = 0;\n        this.baseRotations = 0;\n        // this is here to save computational power by storing the width and height that \n        // shouldn't change\n        this.width = 0;\n        this.height = 0;\n        // refers to the velocity of the second-hand\n        this.velocity = 0;\n        // refers to if the watch is being reset\n        this.isResetting = false;\n    }\n    /**\n     * Use this to load the watch part images.\n     * @param paths the paths/URLs of each watch part\n     */\n    InteractiveWatch.prototype.load = function (paths) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, _c, _i, part, partTyped, _d, _e;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0:\n                        _a = paths;\n                        _b = [];\n                        for (_c in _a)\n                            _b.push(_c);\n                        _i = 0;\n                        _f.label = 1;\n                    case 1:\n                        if (!(_i < _b.length)) return [3 /*break*/, 4];\n                        _c = _b[_i];\n                        if (!(_c in _a)) return [3 /*break*/, 3];\n                        part = _c;\n                        partTyped = part;\n                        _d = this.images;\n                        _e = partTyped;\n                        return [4 /*yield*/, (0,_loadImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(paths[partTyped])];\n                    case 2:\n                        _d[_e] = _f.sent();\n                        _f.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Use this to precompute the sizes it will use for rendering.\n     * @param canvas the canvas element from which it should be rendered from.\n     */\n    InteractiveWatch.prototype.computeSizesFromCanvas = function (canvas) {\n        var body = this.images.body;\n        var scale = Math.min(canvas.width / body.width, canvas.height / body.height);\n        this.width = body.width * scale;\n        this.height = body.height * scale;\n    };\n    /**\n     * Use this to reset the rotation of the watch,\n     * should trigger rotation inverse direction to get to 0.\n     */\n    InteractiveWatch.prototype.resetRotation = function () {\n        this.isResetting = true;\n        this.baseRotations = Math.abs(this.rotations.second);\n    };\n    /**\n     * Use this to rotate the watch hands.\n     * @param unit how much to rotate.\n     * @param adjustToOneSecondDegree by default, 1 unit = 1 degree. if set to true, 1 unit = 6 degrees\n     */\n    InteractiveWatch.prototype.applyRotation = function (unit, adjustToOneSecondDegree) {\n        this.velocity = unit * (adjustToOneSecondDegree ? 1 : 1 / InteractiveWatch.DEGREES_PER_SECOND);\n    };\n    /**\n     * This is the logical update of this object.\n     * Must be called during the update stage.\n     */\n    InteractiveWatch.prototype.update = function () {\n        var rotations = this.rotations;\n        if (this.isResetting) {\n            var repetitions = 0;\n            // when resetting, we use 2% of the base rotations\n            while (repetitions < this.baseRotations * 0.02) {\n                rotations.second -= Math.sign(rotations.second);\n                if (rotations.second === 0) {\n                    this.isResetting = false;\n                    break;\n                }\n                ++repetitions;\n            }\n        }\n        if (!this.isResetting) {\n            rotations.second += Math.floor(InteractiveWatch.DEGREES_PER_SECOND * this.velocity);\n        }\n        // minute hand has snappy changes\n        rotations.minute = Math.floor(rotations.second / InteractiveWatch.DEGREES_PER_SECOND / 60) * InteractiveWatch.DEGREES_PER_MINUTE;\n        // hour hand has smooth changes\n        rotations.hour = (rotations.minute / InteractiveWatch.DEGREES_PER_MINUTE / 60) * InteractiveWatch.DEGREES_PER_HOUR;\n        // reset rotation of seconds to 0 when it reaches 12 hours total\n        rotations.second %= InteractiveWatch.DEGREES_PER_SECOND * 60 * 60 * 12;\n        this.velocity = Math.floor(this.velocity * 0.001);\n    };\n    /**\n     * Use this to render the object into the canvas.\n     * @param context the canvas context where it would be rendered on.\n     */\n    InteractiveWatch.prototype.render = function (context) {\n        var _a = this, width = _a.width, height = _a.height;\n        var canvas = context.canvas;\n        // clear the canvas\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        for (var key in this.images) {\n            var image = this.images[key];\n            var rotation = this.rotations[key];\n            context.save();\n            context.translate(canvas.width / 2, canvas.height / 2);\n            context.rotate(rotation * Math.PI / 180);\n            context.drawImage(image, 0, 0, image.width, image.height, -width / 2, -height / 2, width, height);\n            context.restore();\n        }\n    };\n    // these are constants that is used by this class in order to properly compute values\n    InteractiveWatch.DEGREES_PER_SECOND = 360 / 60;\n    InteractiveWatch.DEGREES_PER_MINUTE = 360 / 60;\n    InteractiveWatch.DEGREES_PER_HOUR = 360 / 12;\n    return InteractiveWatch;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InteractiveWatch);\n\n\n//# sourceURL=webpack://portfolio/./src/InteractiveWatch.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _InteractiveWatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InteractiveWatch */ \"./src/InteractiveWatch.ts\");\n/* harmony import */ var _onViewportChange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./onViewportChange */ \"./src/onViewportChange.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n// import 'animate.css'; // we don't need to import this anymore\n\n\nvar root = document.querySelector('#root');\nvar scrollable = document.querySelector('#scrollable');\nvar canvas = document.querySelector('canvas');\nvar context = canvas.getContext('2d');\nvar watch = new _InteractiveWatch__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\nvar mouseState = { previous: null, current: null, pressed: false };\nvar mouseVectorLatest = null;\nvar now = Date.now();\nvar then = now;\nvar fps = 120;\n/**\n * This is the entrypoint of the program.\n */\nfunction main() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    root.classList.remove('hidden');\n                    scrollable.querySelector('#centerpoint').scrollIntoView({ behavior: 'instant', block: 'center', inline: 'center' });\n                    document.querySelectorAll('[data-scroll-class]').forEach(function (element) {\n                        var handler = (0,_onViewportChange__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element, function (isInViewport) {\n                            var _a, _b;\n                            var classes = element.dataset.scrollClass.split(' ');\n                            if (isInViewport) {\n                                element.classList.remove('hidden');\n                                (_a = element.classList).add.apply(_a, classes);\n                                return;\n                            }\n                            element.classList.add('hidden');\n                            (_b = element.classList).remove.apply(_b, classes);\n                        });\n                        window.addEventListener('customscroll', handler, false);\n                    });\n                    // this allows us to use smooth-scroll on anchor tags\n                    document.querySelectorAll('a.smooth-scroll').forEach(function (element) {\n                        // automatically binds click event listener for smooth scroll\n                        element.addEventListener('click', function (event) {\n                            event.preventDefault();\n                            var target = element.getAttribute('href');\n                            document.querySelector(element.getAttribute('href')).scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });\n                            if (target === '#centerpoint')\n                                watch.resetRotation();\n                        });\n                    });\n                    // all the images must have the same size and that the hands are centered\n                    // in place as if the watch and the other hands are simply invisible\n                    return [4 /*yield*/, watch.load({\n                            body: '/assets/watch/body.png',\n                            hour: '/assets/watch/hour.png',\n                            minute: '/assets/watch/minute.png',\n                            second: '/assets/watch/second.png'\n                        })];\n                case 1:\n                    // all the images must have the same size and that the hands are centered\n                    // in place as if the watch and the other hands are simply invisible\n                    _a.sent();\n                    setup();\n                    loop();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Place your setup code here...\n */\nfunction setup() {\n    // adjust the canvas according to the device's pixel ratio\n    canvas.width *= window.devicePixelRatio;\n    canvas.height *= window.devicePixelRatio;\n    watch.computeSizesFromCanvas(canvas);\n}\n/**\n * This is the update code where logical update\n * steps happen.\n */\nfunction update() {\n    // update the current and previous mouse events\n    mouseState.previous = mouseState.current;\n    mouseState.current = mouseVectorLatest;\n    // this is the logic to compute how much the angle of the watch has changed\n    if (mouseState.pressed && mouseState.previous && mouseState.current && !watch.isResetting) {\n        var canvasBoundingBox = canvas.getBoundingClientRect();\n        var originX = (canvasBoundingBox.left + canvasBoundingBox.right) / 2;\n        var originY = (canvasBoundingBox.top + canvasBoundingBox.bottom) / 2;\n        var previousX = mouseState.previous.x - originX;\n        var previousY = mouseState.previous.y - originY;\n        var previousAngle = atan2(previousY, previousX);\n        var currentX = mouseState.current.x - originX;\n        var currentY = mouseState.current.y - originY;\n        var currentAngle = atan2(currentY, currentX);\n        // convert to degrees, then limit it\n        var totalAngle = (currentAngle - previousAngle) % 30;\n        if ((scrollable.scrollTop > 0) || (scrollable.scrollTop + scrollable.clientHeight < scrollable.scrollHeight))\n            scrollable.scrollTop += totalAngle;\n        watch.applyRotation(totalAngle);\n        window.dispatchEvent(new CustomEvent('customscroll'));\n    }\n    // this must always be called to update the watch\n    watch.update();\n}\n/**\n * @returns the angle (in degrees) from the X axis to a point.\n * @param y A numeric expression representing the cartesian y-coordinate.\n * @param x A numeric expression representing the cartesian x-coordinate.\n */\nfunction atan2(y, x) {\n    var radians = Math.atan2(y, x);\n    var degrees = (radians > 0 ? radians : (2 * Math.PI + radians)) * 360 / (2 * Math.PI);\n    return degrees;\n}\n/**\n * Place all your render code here...\n */\nfunction render() {\n    watch.render(context);\n}\n/**\n * This is the game loop which should call\n * update and render at the right time.\n */\nfunction loop() {\n    window.requestAnimationFrame(loop);\n    now = Date.now();\n    var elapsed = now - then;\n    var interval = 1000 / fps;\n    if (elapsed > interval) {\n        then = now - (elapsed % interval);\n        update();\n        render();\n    }\n}\nfunction resetMouseState() {\n    mouseState.previous = null;\n    mouseState.current = null;\n    mouseState.pressed = false;\n}\n/**\n * This sets the mouse state to be pressed.\n */\nwindow.addEventListener('mousedown', function () {\n    mouseState.pressed = true;\n});\n/**\n * This resets the mouse state to its default values.\n */\nwindow.addEventListener('mouseup', function () {\n    resetMouseState();\n    watch.applyRotation(0);\n});\n/**\n * This is fired when the mouse is moved, we simply save\n * the latest mouse event.\n */\nwindow.addEventListener('mousemove', function (event) {\n    mouseVectorLatest = { x: event.clientX, y: event.clientY };\n});\n/**\n * Mobile devices use touch events instead, same logic, this is for touching down.\n */\nwindow.addEventListener('touchstart', function () {\n    mouseState.pressed = true;\n}, { passive: false });\n/**\n * This is for stopping the touch.\n */\nwindow.addEventListener('touchend', function () {\n    resetMouseState();\n    watch.applyRotation(0);\n});\n/**\n * This is for when the touch is being moved.\n */\nwindow.addEventListener('touchmove', function (event) {\n    event.preventDefault();\n    mouseVectorLatest = { x: event.touches[0].clientX, y: event.touches[0].clientY };\n}, { passive: false });\n/**\n * This prevents scrolling normally on the scrollable content.\n */\nscrollable.addEventListener('wheel', function (event) {\n    event.preventDefault();\n}, { passive: false });\nwindow.addEventListener('load', main);\n\n\n//# sourceURL=webpack://portfolio/./src/index.ts?");

/***/ }),

/***/ "./src/loadImage.ts":
/*!**************************!*\
  !*** ./src/loadImage.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Use this to asynchronously load an image from a URL.\n * @param url the URL or path of the image to be loaded.\n * @returns a promise that should resolve to an HTMLImageElement.\n */\nfunction loadImage(url) {\n    return new Promise(function (resolve, reject) {\n        var image = new Image();\n        image.onload = function () { return resolve(image); };\n        image.onerror = function () { return reject(); };\n        image.src = url;\n    });\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (loadImage);\n\n\n//# sourceURL=webpack://portfolio/./src/loadImage.ts?");

/***/ }),

/***/ "./src/onViewportChange.ts":
/*!*********************************!*\
  !*** ./src/onViewportChange.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// this adjusts the isElementInViewport function condition by a set amount\nvar ADJUST_TOP_HEIGHT_REQUIREMENT = 100;\n/**\n * Use this to determine whether an element is in viewpoer or not.\n * @param element an HTMLElement.\n * @returns a boolean indicating whether said HTMLElement is in the viewpoint.\n */\nfunction isElementInViewport(element) {\n    var rectangle = element.getBoundingClientRect();\n    return rectangle.bottom > 0 &&\n        rectangle.right > 0 &&\n        rectangle.left < (window.innerWidth || document.documentElement.clientWidth) &&\n        rectangle.top + ADJUST_TOP_HEIGHT_REQUIREMENT < (window.innerHeight || document.documentElement.clientHeight);\n}\n/**\n * Use this to create a handler that will only call the callback when element\n * is in viewport.\n * @param element an HTMLElement.\n * @param callback the callback function when element goes in/out of viewport.\n * @returns\n */\nfunction onViewportChange(element, callback) {\n    var previousState;\n    return function () {\n        var currentState = isElementInViewport(element);\n        if (currentState != previousState) {\n            previousState = currentState;\n            callback(currentState);\n        }\n    };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (onViewportChange);\n\n\n//# sourceURL=webpack://portfolio/./src/onViewportChange.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;