/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./js/Color.js":
/*!*********************!*\
  !*** ./js/Color.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nvar Color = /*#__PURE__*/function () {\n  function Color(r, g, b, a) {\n    _classCallCheck(this, Color);\n    this.rgba = new Uint8Array([r, g, b, a]);\n  }\n  _createClass(Color, [{\n    key: \"equalTo\",\n    value: function equalTo(otherColor) {\n      for (var index = 0; index < 3; ++index) {\n        if (otherColor.rgba[index] != this.rgba[index]) return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"unpack\",\n    value: function unpack() {\n      return [this.rgba[0], this.rgba[1], this.rgba[2], this.rgba[3]];\n    }\n  }]);\n  return Color;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Color);\n\n//# sourceURL=webpack://portfolio/./js/Color.js?");

/***/ }),

/***/ "./js/MapEmitter.js":
/*!**************************!*\
  !*** ./js/MapEmitter.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Queue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Queue.js */ \"./js/Queue.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar MapEmitter = /*#__PURE__*/function () {\n  function MapEmitter(sourceMap, sourceWidth, sourceHeight, _ref) {\n    var _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y,\n      _ref$range = _ref.range,\n      range = _ref$range === void 0 ? 20 : _ref$range,\n      _ref$value = _ref.value,\n      value = _ref$value === void 0 ? 2 : _ref$value,\n      _ref$spread = _ref.spread,\n      spread = _ref$spread === void 0 ? 100 : _ref$spread;\n    _classCallCheck(this, MapEmitter);\n    this.x = x;\n    this.y = y;\n    this.value = value;\n    this.range = range;\n    this.spreadCurrent = 0;\n    this.spreadLimit = spread;\n    this.spreadQueue = null;\n    this.isFilling = true;\n    this.isFinished = false;\n    this.map = sourceMap;\n    this.width = sourceWidth;\n    this.height = sourceHeight;\n  }\n\n  /**\n   *\n   *\n   */\n  _createClass(MapEmitter, [{\n    key: \"setup\",\n    value: function setup() {\n      this._initializeSpreadQueue(0);\n    }\n\n    /**\n     *\n     */\n    // flood-fill algorithm implementation, \n    // single-step only for animation\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.isFinished) return;\n      for (var times = 0; times < this.spreadLimit * 0.1; ++times) {\n        if (this.spreadQueue.isEmpty || this.isFilling && this.spreadCurrent >= this.spreadLimit) {\n          this._initializeSpreadQueue(this.value);\n          this.isFilling = false;\n        } else if (!this.isFilling && this.spreadQueue.isEmpty) {\n          this.spreadCurrent = 0;\n          this.isFinished = true;\n          break;\n        }\n        var height = this.height,\n          width = this.width;\n        var index = this.spreadQueue.dequeue();\n        var targetValue = this.isFilling ? 0 : this.value;\n        var fillValue = this.isFilling ? this.value : 0;\n        if (this.map[index] == targetValue) {\n          this.map[index] = fillValue;\n\n          // boundary checking i.e. if the current cell has neighbors\n          // the checks are for as follows: top, bottom, left, and right\n          if (index >= width) this.spreadQueue.enqueue(index - width);\n          if (index <= width * (height - 1) + 1) this.spreadQueue.enqueue(index + width);\n          if (index % width != 0) this.spreadQueue.enqueue(index - 1);\n          if (index % (width + 1) != 0) this.spreadQueue.enqueue(index + 1);\n          if (this.isFilling) this.spreadCurrent++;\n        }\n      }\n    }\n  }, {\n    key: \"_initializeSpreadQueue\",\n    value: function _initializeSpreadQueue(targetValue) {\n      // from (x, y) we want to select spots from each of the 4 cardinal directions \n      // until range is reached\n      this.spreadQueue = new _Queue_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n      var x = this.x,\n        y = this.y,\n        width = this.width,\n        height = this.height;\n      var index = y * width + x;\n      var offset = 1;\n      while (offset < this.range) {\n        var top = index - width * offset;\n        var bottom = index + width * offset;\n        var left = index - offset;\n        var right = index + offset;\n\n        // boundary checking if the current element from the offset\n        // is valid, it is valid if it is on the same row and column, \n        // it exists and is an empty space (equal to 0)\n        if (top >= 0 && this.map[top] == targetValue) this.spreadQueue.enqueue(top);\n        if (bottom <= width * height - 1 && this.map[bottom] == targetValue) this.spreadQueue.enqueue(bottom);\n        if (Math.floor(left / width) == y && this.map[left] == targetValue) this.spreadQueue.enqueue(left);\n        if (Math.floor(right / width) == y && this.map[right] == targetValue) this.spreadQueue.enqueue(right);\n        ++offset;\n      }\n    }\n  }]);\n  return MapEmitter;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapEmitter);\n\n//# sourceURL=webpack://portfolio/./js/MapEmitter.js?");

/***/ }),

/***/ "./js/MapEmitterRenderer.js":
/*!**********************************!*\
  !*** ./js/MapEmitterRenderer.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Color.js */ \"./js/Color.js\");\n/* harmony import */ var _MapEmitter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MapEmitter.js */ \"./js/MapEmitter.js\");\n/* harmony import */ var _Queue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Queue.js */ \"./js/Queue.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\nvar MapEmitterRenderer = /*#__PURE__*/function () {\n  function MapEmitterRenderer(imagePath, windowElement, canvasElement, _ref) {\n    var _ref$sourceBackground = _ref.sourceBackgroundColor,\n      sourceBackgroundColor = _ref$sourceBackground === void 0 ? new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, 0) : _ref$sourceBackground,\n      _ref$targetBackground = _ref.targetBackgroundColor,\n      targetBackgroundColor = _ref$targetBackground === void 0 ? new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, 0) : _ref$targetBackground,\n      _ref$targetForeground = _ref.targetForegroundColor,\n      targetForegroundColor = _ref$targetForeground === void 0 ? new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](100, 100, 100) : _ref$targetForeground,\n      _ref$targetActiveFore = _ref.targetActiveForegroundColor,\n      targetActiveForegroundColor = _ref$targetActiveFore === void 0 ? new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](255, 255, 255) : _ref$targetActiveFore;\n    _classCallCheck(this, MapEmitterRenderer);\n    this.sourceData = null;\n    this.targetData = null;\n    this.width = null;\n    this.height = null;\n\n    // 0 - part of the board (empty)\n    // 1 - wall, not fillable\n    // 2 - part of the board (filled)\n    this.sourceMap = null;\n    this.sourceMapIndices = null;\n    this.sourcePath = imagePath;\n    this.sourceBackgroundColor = sourceBackgroundColor;\n    this.targetBackgroundColor = targetBackgroundColor;\n    this.targetForegroundColor = targetForegroundColor;\n    this.targetActiveForegroundColor = targetActiveForegroundColor;\n    this.emitters = [];\n    this.window = windowElement;\n    this.canvas = canvasElement;\n    this.context = canvasElement.getContext('2d');\n    this.isFinished = false;\n  }\n\n  /**\n   * \n   */\n  _createClass(MapEmitterRenderer, [{\n    key: \"load\",\n    value: function load(onLoadCallback) {\n      var _this = this;\n      var image = new Image();\n      image.crossOrigin = '*';\n      image.onload = function () {\n        var canvas = document.createElement(\"canvas\");\n        var context = canvas.getContext(\"2d\");\n        var sourceWidth = image.width,\n          sourceHeight = image.height;\n        var _this$canvas = _this.canvas,\n          targetWidth = _this$canvas.width,\n          targetHeight = _this$canvas.height;\n        canvas.width = targetWidth;\n        canvas.height = targetHeight;\n        var originX = sourceWidth / 2 - targetWidth / 2;\n        var originY = sourceHeight / 2 - targetHeight / 2;\n        context.drawImage(image, -originX, -originY);\n        _this.sourceData = context.getImageData(0, 0, targetWidth, targetHeight);\n        _this.width = targetWidth;\n        _this.height = targetHeight;\n        // context.clearRect(0, 0, targetWidth, targetHeight); // could be commented, maybe no performance gain here\n\n        if (onLoadCallback) onLoadCallback();\n      };\n      image.src = this.sourcePath;\n    }\n\n    /**\n     * \n     */\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      this._initializeSourceMap();\n      this._initializeSourceMapIndices();\n      this._initializeTargetData();\n    }\n\n    /**\n     * \n     */\n    // flood-fill algorithm that's breadth-first\n  }, {\n    key: \"update\",\n    value: function update() {\n      for (var index = this.emitters.length - 1; index >= 0; --index) {\n        var emitter = this.emitters[index];\n        if (emitter.isFinished) {\n          this.emitters.splice(index, 1);\n          continue;\n        }\n        emitter.update();\n      }\n      var pixels = this.targetData.data;\n      for (var index = 0; index < this.sourceMapIndices.length; ++index) {\n        var targetDataIndex = this.sourceMapIndices[index];\n        var sourceValue = this.sourceMap[targetDataIndex];\n        var color = sourceValue == 0 ? this.targetForegroundColor : this.targetActiveForegroundColor;\n        var _color$unpack = color.unpack(),\n          _color$unpack2 = _slicedToArray(_color$unpack, 4),\n          r = _color$unpack2[0],\n          g = _color$unpack2[1],\n          b = _color$unpack2[2],\n          a = _color$unpack2[3];\n        var pixelIndex = targetDataIndex * 4;\n        pixels[pixelIndex] = r;\n        pixels[pixelIndex + 1] = g;\n        pixels[pixelIndex + 2] = b;\n        pixels[pixelIndex + 3] = a;\n      }\n    }\n\n    /**\n     * \n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.context.putImageData(this.targetData, 0, 0);\n    }\n  }, {\n    key: \"createEmitter\",\n    value: function createEmitter(x, y, range, spread) {\n      var sourceMap = this.sourceMap,\n        width = this.width,\n        height = this.height;\n      var emitter = new _MapEmitter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](sourceMap, width, height, {\n        x: x,\n        y: y,\n        value: this.emitters.length + 2,\n        range: range,\n        spread: spread\n      });\n      emitter.setup();\n      this.emitters.push(emitter);\n    }\n\n    /**\n     * \n     */\n  }, {\n    key: \"_initializeSourceMap\",\n    value: function _initializeSourceMap() {\n      var pixels = this.sourceData.data;\n      this.sourceMap = new Uint8Array(Math.floor(pixels.length * 0.25));\n      var mapIndex = 0;\n\n      // store a new map with only 0s and 1s where 0 means it is open\n      // and 1 means it is a wall\n      for (var index = 0; index < pixels.length / 4; ++index) {\n        var current = index * 4;\n        var color = new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](pixels[current], pixels[current + 1], pixels[current + 2], pixels[current + 3]);\n        var isWall = 1;\n\n        // if the pixel does not match the background color pixel \n        // then, it must not be a wall\n        if (!this.sourceBackgroundColor.equalTo(color)) {\n          isWall = 0;\n        }\n        this.sourceMap[mapIndex] = isWall;\n        ++mapIndex;\n      }\n    }\n\n    /**\n     *\n     */\n  }, {\n    key: \"_initializeSourceMapIndices\",\n    value: function _initializeSourceMapIndices() {\n      var indices = new Uint32Array(this.sourceMap.length);\n      var indicesIndex = 0;\n\n      // store all indices that are not walls\n      for (var index = 0; index < this.sourceMap.length; ++index) {\n        // 1 means it is a wall, hence 0, 2, and other values aren't walls\n        if (this.sourceMap[index] != 1) indices[indicesIndex++] = index;\n      }\n\n      // we then copy the values and place it accordingly\n      this.sourceMapIndices = new Uint32Array(indicesIndex);\n      for (var _index = 0; _index < indicesIndex; ++_index) {\n        this.sourceMapIndices[_index] = indices[_index];\n      }\n    }\n\n    /**\n     * \n     */\n  }, {\n    key: \"_initializeTargetData\",\n    value: function _initializeTargetData() {\n      this.targetData = new ImageData(this.sourceData.width, this.sourceData.height);\n      var pixels = this.targetData.data;\n      var _this$targetBackgroun = this.targetBackgroundColor.unpack(),\n        _this$targetBackgroun2 = _slicedToArray(_this$targetBackgroun, 4),\n        r1 = _this$targetBackgroun2[0],\n        g1 = _this$targetBackgroun2[1],\n        b1 = _this$targetBackgroun2[2],\n        a1 = _this$targetBackgroun2[3];\n      var _this$targetForegroun = this.targetForegroundColor.unpack(),\n        _this$targetForegroun2 = _slicedToArray(_this$targetForegroun, 4),\n        r2 = _this$targetForegroun2[0],\n        g2 = _this$targetForegroun2[1],\n        b2 = _this$targetForegroun2[2],\n        a2 = _this$targetForegroun2[3];\n\n      // set the targetData to render the backgroundColor\n      for (var index = 0; index < pixels.length / 4; ++index) {\n        var current = index * 4;\n        pixels[current] = r1;\n        pixels[current + 1] = g1;\n        pixels[current + 2] = b1;\n        pixels[current + 3] = a1; // alpha channel\n      }\n\n      // set the targetData to show the pattern with foregroundColor\n      for (var _index2 = 0; _index2 < this.sourceMapIndices.length; ++_index2) {\n        var _current = this.sourceMapIndices[_index2] * 4;\n        pixels[_current] = r2;\n        pixels[_current + 1] = g2;\n        pixels[_current + 2] = b2;\n        pixels[_current + 3] = a2;\n      }\n    }\n  }]);\n  return MapEmitterRenderer;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapEmitterRenderer);\n\n//# sourceURL=webpack://portfolio/./js/MapEmitterRenderer.js?");

/***/ }),

/***/ "./js/Queue.js":
/*!*********************!*\
  !*** ./js/Queue.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nvar Queue = /*#__PURE__*/function () {\n  function Queue() {\n    _classCallCheck(this, Queue);\n    this.elements = {};\n    this.head = 0;\n    this.tail = 0;\n  }\n  _createClass(Queue, [{\n    key: \"enqueue\",\n    value: function enqueue(element) {\n      this.elements[this.tail++] = element;\n    }\n  }, {\n    key: \"dequeue\",\n    value: function dequeue() {\n      var item = this.elements[this.head];\n      delete this.elements[this.head++];\n      return item;\n    }\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.elements[this.head];\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.tail - this.head;\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.length === 0;\n    }\n  }]);\n  return Queue;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Queue);\n\n//# sourceURL=webpack://portfolio/./js/Queue.js?");

/***/ }),

/***/ "./js/index.js":
/*!*********************!*\
  !*** ./js/index.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Color.js */ \"./js/Color.js\");\n/* harmony import */ var _MapEmitterRenderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MapEmitterRenderer.js */ \"./js/MapEmitterRenderer.js\");\n/* harmony import */ var _MapEmitter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MapEmitter.js */ \"./js/MapEmitter.js\");\n\n\n\nvar loader = document.querySelector(\".loader-layer\");\nvar content = document.querySelector(\".content-layer\");\n// const gradient = document.querySelector(\".gradient-layer\");\nvar canvas = document.querySelector(\".cover-layer\");\nvar _window$document$body = window.document.body,\n  width = _window$document$body.clientWidth,\n  height = _window$document$body.clientHeight;\nvar mapRenderer;\nvar scale;\nvar finalPath;\nvar now, then;\nvar fps;\n\n/**\n *\n *\n */\nfunction getPresets(basis) {\n  var basePath = \"../images/background\";\n  var _window = window,\n    devicePixelRatio = _window.devicePixelRatio,\n    innerWidth = _window.innerWidth;\n  switch (basis) {\n    case 'DPI':\n      return {\n        scale: devicePixelRatio,\n        finalPath: devicePixelRatio > 1.0 ? \"\".concat(basePath, \"/pattern-dpi-2x-3x.png\") : \"\".concat(basePath, \"/pattern-dpi-1x.png\")\n      };\n      break;\n    case 'screen-width':\n      return {\n        scale: Math.max(2.5, devicePixelRatio),\n        finalPath: innerWidth > 480 ? \"\".concat(basePath, \"/pattern-desktop.png\") : \"\".concat(basePath, \"/pattern-mobile.png\")\n      };\n      break;\n  }\n}\n\n/**\n *\n *\n */\nfunction main() {\n  // hide all the content\n  // gradient.style.visibility = \"hidden\";\n  loader.style.zIndex = \"99\";\n  loader.style.display = \"block\";\n  content.style.visibility = \"hidden\";\n  var _getPresets = getPresets('screen-width');\n  scale = _getPresets.scale;\n  finalPath = _getPresets.finalPath;\n  mapRenderer = new _MapEmitterRenderer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](finalPath, window, canvas, {\n    sourceBackgroundColor: new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](23, 23, 23, 255),\n    targetBackgroundColor: new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, 139, 255),\n    targetForegroundColor: new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](8, 22, 209, 255),\n    targetActiveForegroundColor: new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, 0, 0)\n  });\n  now = Date.now();\n  then = now;\n  fps = 60;\n\n  // this is for matching the DPI to keep the output crisp\n  canvas.width = Math.ceil(width * scale);\n  canvas.height = Math.ceil(height * scale);\n  canvas.style.width = \"\".concat(width, \"px\");\n  canvas.style.height = \"\".concat(height, \"px\");\n  mapRenderer.load(function () {\n    setup();\n    loop();\n    document.addEventListener(\"click\", handleClickScreen);\n  });\n}\n\n/**\n *\n */\nfunction setup() {\n  // gradient.style.visibility = \"visible\";\n  loader.style.display = \"none\";\n  content.style.visibility = \"visible\";\n  mapRenderer.setup();\n  console.log(mapRenderer);\n}\n\n/**\n *\n */\nfunction update() {\n  mapRenderer.update();\n}\n\n/**\n *\n */\nfunction render() {\n  mapRenderer.render();\n}\n\n/**\n *\n */\nfunction loop() {\n  window.requestAnimationFrame(loop);\n  now = Date.now();\n  var elapsed = now - then;\n  var interval = 1000 / fps;\n  if (elapsed > interval) {\n    then = now - elapsed % interval;\n    update();\n    render();\n  }\n}\nfunction handleClickScreen(event) {\n  var x = event.pageX * scale;\n  var y = event.pageY * scale;\n  mapRenderer.createEmitter(x, y, 250, 50000);\n}\nmain();\n\n//# sourceURL=webpack://portfolio/./js/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./js/index.js");
/******/ 	
/******/ })()
;